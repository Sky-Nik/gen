\documentclass[a4paper, 12pt]{article}
\input{../../sty/use.sty}
\input{../../sty/th.sty}
\input{../../sty/cmd.sty}
\input{../../sty/cover.sty}

\author{Скибицький Нікіта}
\date{\today}

\allowdisplaybreaks
\numberwithin{equation}{section}
\linespread{1.15}

\begin{document}

\cover{2}{Генетичний алгоритм}

\tableofcontents

\section{Неформальний опис алгоритму}

\subsection{Власне опис}

\subsection{Історія винаходу методу}

\subsection{Сфери застосування}

\subsection{Можливі модифікації}

\section{Формалізований опис алгоритму}

Нехай є певна фітнес-функція $f$: $\mathbb{R}^m \to \mathbb{R}$ і ставиться оптимцізаційна задача
\begin{equation}
    f(x) \xrightarrow[x \in \mathcal{C}]{} \min,
\end{equation}
де $\mathcal{C} \subset \mathbb{R}^m$ --- опукла і замкнена допустима множина, наприклад $\mathcal{C} = [x_{\text{min}}, x_{\text{max}}]^m$. \medskip

Розглянемо популяцію з $n$ особин які протягом $M$ поколінь розв'язують цю оптимізаційну задачу (пристосовуються під задану фітнес-функцію). Кожну особину будемо описувати двійковим вектором достатньо довгим для того щоб кодувати десяткові значення аргументів функції $x_i$ з потрібною точністю $\varepsilon$. \medskip

Перше покоління не має досвіду предків і генерується випадковим чином, рівномірно на $\mathcal{C}$. \medskip

Далі з кожним поколінням відбуваються наступні речі:
\begin{itemize}
    \item воно кодується з десяткового представлення у двійкове;
    \item у ньому із заданою ймовірністю $p$ відбувають бітові мутації;
    \item покоління розбивається на пари, між якими відбувається кроссовер (обмін генами);
    \item на основі покоління генерується нове таким чином що найкращі особини мають більшу ймовірність мати нащадка.
\end{itemize}

\section{Код програмного продукту}

\subsection{GenerationDec}

\subsubsection{Призначення}

Ця процедура заповнює матрицю із заданою кількістю рядків і стовпчиків випадковими десятковими числами із заданого діапазону. \medskip

Діапазон значень фіксований для усіх елементів кожного стовпчика матриці. \medskip

Елементи останнього стовпчика матриці не заповнюються випадковими числами і призначені для обчислення значень фітнес-функції, аргументами якої є всі попередні елементи рядка матриці.

\subsubsection{Вхідні параметри}

\begin{itemize}
    \item $N, M$ --- цілі невід'ємні числа
    \item $X_{\text{min}}(1..M), X_{\text{max}}(1..M)$ --- масиви дійсних чисел, $X_{\text{min}}[i] < X_{\text{max}}[i]$, $i = \overline{1..M}$;
\end{itemize}

\subsubsection{Вихідні параметри}

\begin{itemize}
    \item $G(1..N, 1..M+1)$ --- матриця випадкових значень.
\end{itemize}

\subsubsection{Обчислення}

Заповнює елементи матриці $G[i,j]$, $i = \overline{1..N}$, $j = \overline{1..M}$, $X_{\text{min}}[j] \le G[i, j] \le X_{\text{max}}[j]$.

\subsubsection{Вказівки}

Для генерування випадкових чисел з заданого діапазону використовувати функцію Generate пакета Random Tools.

\subsubsection{Власне реалізація}

\inputminted[firstline=7, lastline=40]{python}{../code/generation_dec.py}

\subsection{Mutation}

\subsubsection{Призначення}

Опрацьовує в циклі кожен елемент прямокутної матриці заданого розміру з елементами 0 або 1 за наступним правилом: 
\begin{itemize}
    \item якщо згенероване випадкове число менше заданого порогового значення, то відповідний елемент матриці інвертується (0 в 1 або 1 в 0);
    \item інакше елемент матриці не змінюється. 
\end{itemize}

Результат зберігається у новій матриці.

\subsubsection{Вхідні параметри}

\begin{itemize}
    \item $G$ --- прямокутна матриця зі значеннями 0 або 1;
    \item $p$ --- дійсне число $0 < p \ll 1$ --- ймовірність мутації.
\end{itemize}

\subsubsection{Вихідні параметри}

\begin{itemize}
    \item $G_{\text{mut}}$ --- прямокутна матриця зі значеннями 0 або 1, розмірність якої дорівнює розмірності $G$;
    \item $S_{\text{mut}}$ --- лічильних загальної кількості мутацій, що були виконані для матриці $G$.
\end{itemize}

\subsubsection{Обчислення}

\begin{itemize}
    \item В циклі опрацювати кожен елемент матриці $G$, перевіряючи умову, що згенероване випадкове число менше заданого параметра $p$. 
    \item При виконанні умови виконати мутацію, інакше елемент матриці не змінюється. 
    \item При кожній мутації збільшувати лічильник на одиницю.
\end{itemize}

\subsubsection{Вказівки}

Для генерування випадкових чисел з заданого діапазону можна використовувати функцію Generate з пакету Random Tools.

\subsubsection{Власне реалізація}

\inputminted[firstline=6, lastline=15]{python}{../code/mutation.py}

\subsection{Crossover}

\subsection{Parents}

\subsection{BinDecParam}

\subsection{CodBinary}

\subsubsection{Призначення}

Процедура виконує кодування довільного дійсного числа $x_{\text{dec}}$ з заданого діапазону $[x_{\text{min}}..x_{\text{max}}]$ з заданою точністю $\varepsilon$ у послідовність з 0 і 1 фіксованої довжини. \medskip

Процедура працює у парі з процедурою CodDecimal, яка виконує зворотнє перетворення. \medskip

Допоміжні параметри обчислюються процедурою BinDecParam.

\subsubsection{Вхідні параметри}

\begin{itemize}
    \item $x_{\text{dec}}$ --- десяткове число;
    \item $x_{\text{min}}$ --- мінімальне значення числа, що кодується;
    \item $l$ --- ціле число, максимальна кількість двійкових розрядів для представлення довільного числа із заданого діапазону із заданою точністю;
    \item $d$ --- дискретність кодування дійсного числа $x_{\text{dec}}$ цілим числом.
\end{itemize}

\subsubsection{Вихідні параметри}

\begin{itemize}
    \item $X_{\text{bin}}$ --- список з $l$ розрядів двійкового числа, молодші розряді йдуть спочатку. 
\end{itemize}

У разі потреби старші розряди дозаповнюються нулями.

\subsubsection{Обчислення}

Ціле число частин величини $d$ для заданого числа $x_{\text{dec}}$ можно обчислити як
\begin{equation}
    xx = \left[ \frac{x_{\text{dec}} - x_{\text{min}}}{d} \right].
\end{equation}

Ціле число $xx$ записуємо у двійковій формі і доповнюємо старші розряди нулями, якщо їхня кількість менше $l$.

\subsubsection{Вказівки}

Значення $l$ і $d$ обчислюються процедурою BinDecParam і не можуть задаватися довільно. \medskip

Перетворення цілого десяткового числа у двійковий код (список 0 і 1) можна виконати функцією convert(xx, base, 2).

\subsubsection{Власне реалізація}

\inputminted[firstline=7, lastline=28]{python}{../code/cod_binary.py}

\subsection{CodDecimal}

\subsection{ACodBinary}

\subsubsection{Призначення}

Послідовно перетворює дійсні числа, а саме елементи матриці $G_{\text{dec}}(1..N,1..M+1)$, яка складається з $N$ рядків і $M + 1$ стовпчиків у двійковий код. \medskip

Перетворення виконуються над елементами тільки $M$ перших стовпчиків. \medskip

Для перетворення кожного елемента матриці використовуються процедури CodBinary і BinDecParam. \medskip

Результати перетворення дійсних чисел зберігаються у матрицю Gbin з елементами 0 або 1. \medskip

Кожному стовпчику матриці $G_{\text{dec}}$ відповідає фіксована кількість стовпчиків матриці $G_{\text{bin}}$, яка визначається діапазоном дійсних значень які кодуються і точністю їхнього представлення (див. процедуру [CodBinary](cod_binary.md), параметр $l$).

\subsubsection{Вхідні параметри}

\begin{itemize}
    \item $N, M$ --- розмірності матриці $G_{\text{dec}}(1..N,1..M+1)$;
    \item Матриця $G_{\text{dec}}(1..N,1..M+1)$;
    \item $X_{\text{min}}(1..M)$ --- масив, де $X_{\text{min}}[j]$ --- мінімальне значення елементів стовпчика $j$;
    \item Глобальні параметри процедури BinDecParam: $nn, dd, NN$.
\end{itemize}

\subsubsection{Вихідні параметри}

\begin{itemize}
    \item Матриця $G_{\text{bin}}$ з елементами 0 або 1, яка складається з $N$ рядків, кількість стовпчиків матриці визначається значенням $NN \cdot (M + 1)$.
\end{itemize}

\subsubsection{Обчислення}

В циклі опрацьовуємо кожний елемент матриці $G_{\text{dec}}$, використовуємо процедуру [CodBinary](cod_binary.md), записуємо результати перетворення у матрицю $G_{\text{bin}}$ розмірності $(1..N, 1..NN \cdot [M+1])$.

\subsubsection{Вказівки}

Використовувати для обробки кожного елемента вихідної матриці процедуру CodBinary.

\subsubsection{Власне реалізація}

\inputminted[firstline=31, lastline=73]{python}{../code/cod_binary.py}

\subsection{ACodDecimal}

\subsection{Adapt}

\subsection{Best і Worst}

\subsection{NewGeneration}

\section{Тестування програмного продукту}

\newpage
\bibliography{main}
\bibliographystyle{ieeetr}

\end{document}